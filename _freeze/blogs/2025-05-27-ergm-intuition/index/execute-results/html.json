{
  "hash": "4e68c7d0a788073d7e16d90c14b2b410",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"ERGM Parameter Values\"\ndescription: \"Some intuition about the ERGM coefficients\"\nauthor:\n  - name: Michael D. Siciliano\n    url: https://m-siciliano.github.io/\n    orcid: 0000-0001-8688-8685\n    affiliation: Networks and Governance Lab, Department of Public Policy, Management, and Analytics , University of Illinois Chicago\n    affiliation-url: https://cuppa.uic.edu/academics/pa/\ndate: 2025-05-27\ncategories: [ERGM] # self-defined categories\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\n---\n\n\n\n\n## Where do ERGM Parameter Values Come From?\n\nThis short blog post will give some intuition behind the coefficient values that are estimated when you run an ERGM.\n\nLet's first load out libraries.\n\n\n\n\n::: {.cell messsage='false'}\n\n```{.r .cell-code}\nlibrary(statnet)\nlibrary(ggplot2)\n```\n:::\n\n\n\n\nNow, let's suppose we go out in the world and we collect some network data and we want to model the data to get a better sense of the processes that may be at work in determining the ties. Rather than actually collecting data, let's play god for a minute and simulate some data. The benefit of this, for our purposes, is that we know the true data generating process and so know the true coefficient values that generated our observed data. We will call this `g.true`. Below, we will assume we don't know these coefficient values, and will simulate a bunch of networks with different values to try and hone in on the correct coefficients.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(181318)\ng.true <- simulate(network(57) ~ edges + mutual, coef=c(-1, 2), nsim = 1)\nsummary(g.true ~ edges + mutual) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n edges mutual \n  1517    529 \n```\n\n\n:::\n:::\n\n\n\n\nBased on this data we created, the observed number of edges is 1517 and there are 529 mutual ties. Let's save these values and plot the data.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrue.edges = summary(g.true ~ edges)\ntrue.mutual = summary(g.true ~ mutual)\nplot(g.true)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n\nNow let's assume we don't know the model that generated that data. So we don't know these coefficients, but we have the data and we know how many edges and mutual ties there are in our data. Let's also assume we have some theory which (correctly) tells us that the two key processes that built up by our data can be captured by the following ergm terms: edges and mutual. Thus, our nodes have some underlying tendency to want to form ties (this is our edge term) and also a tendency to want to form mutual ties.\n\nSo now we need to explore possible values for our coefficients. Let's try -2 and .5. And given those values, we will simulate 200 different networks that could be derived given those coefficients.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng.sim <- simulate(network(57) ~ edges + mutual, coef =c(-2, .5), nsim = 200, sequential = FALSE)\n```\n:::\n\n\n\n\nAnd just out of curiosity we can take a look at the summary statistics for just the first simulated network.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(g.sim[[1]] ~ edges + mutual) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n edges mutual \n   390     38 \n```\n\n\n:::\n:::\n\n\n\n\nHere, we can see we are way off of the true values. We are only producing 390 edges and only 38 mutuals. And while this is only 1 of our simulated networks, we suspect that these are likely not the correct coefficients as they are unlikely to have created our true network. To provide more insight into this and use all of our simulated data, let's grab the count of edges and mutuals for all simulated networks and plot that distribution against the values we found in our true network. I'll plot the true values in blue.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng.sim.edges = vector()\nfor (i in 1:200)\n  g.sim.edges[i] = summary(g.sim[[i]] ~ edges)\n\ng.sim.mutual = vector()\nfor (i in 1:200)\n  g.sim.mutual[i] = summary(g.sim[[i]] ~ mutual)\n\ng.sim.data = as.data.frame(cbind(g.sim.edges, g.sim.mutual))\n\nggplot(g.sim.data, aes(x = g.sim.edges, y = g.sim.mutual)) + geom_point() + \n  geom_point(aes(x=true.edges, y=true.mutual), colour=\"blue\", size = 5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n\nNote, the additional geom_point is to plot the location of our observed data, which had 1517 edges and 529 mutual ties.\n\nWhen we plot the number of edges versus mutual ties for all of the networks simulated from this model we see that our observed data, is nowhere near that distribution. It is unlikely we would ever observe our data if these were in fact the correct parameters.\n\nSo what happends now, is that we need to update our parameter and because we underestimated the number of edges and mutuals, let's increase these values. And repeate the process.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng.sim2 <- simulate(network(57) ~ edges + mutual, coef =c(-1.5, .75), nsim = 200, sequential = FALSE)\n\ng.sim.edges = vector()\nfor (i in 1:200)\n  g.sim.edges[i] = summary(g.sim2[[i]] ~ edges)\n\ng.sim.mutual = vector()\nfor (i in 1:200)\n  g.sim.mutual[i] = summary(g.sim2[[i]] ~ mutual)\n\ng.sim.data = as.data.frame(cbind(g.sim.edges, g.sim.mutual))\n\nggplot(g.sim.data, aes(x = g.sim.edges, y = g.sim.mutual)) + geom_point() + \n  geom_point(aes(x=true.edges, y=true.mutual), colour=\"blue\", size = 5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n\nStill not great. Let's increase our parameter values again.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng.sim3 <- simulate(network(57) ~ edges + mutual, coef =c(-1, 1), nsim = 200, sequential = FALSE)\n\ng.sim.edges = vector()\nfor (i in 1:200)\n  g.sim.edges[i] = summary(g.sim3[[i]] ~ edges)\n\ng.sim.mutual = vector()\nfor (i in 1:200)\n  g.sim.mutual[i] = summary(g.sim3[[i]] ~ mutual)\n\ng.sim.data = as.data.frame(cbind(g.sim.edges, g.sim.mutual))\n\nggplot(g.sim.data, aes(x = g.sim.edges, y = g.sim.mutual)) + geom_point() + \n  geom_point(aes(x=true.edges, y=true.mutual), colour=\"blue\", size = 5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n\nThis is better. Let's try to improve.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng.sim4 <- simulate(network(57) ~ edges + mutual, coef =c(-.5, 2), nsim = 200, sequential = FALSE)\n\ng.sim.edges = vector()\nfor (i in 1:200)\n  g.sim.edges[i] = summary(g.sim4[[i]] ~ edges)\n\ng.sim.mutual = vector()\nfor (i in 1:200)\n  g.sim.mutual[i] = summary(g.sim4[[i]] ~ mutual)\n\ng.sim.data = as.data.frame(cbind(g.sim.edges, g.sim.mutual))\n\nggplot(g.sim.data, aes(x = g.sim.edges, y = g.sim.mutual)) + geom_point() + \n  geom_point(aes(x=true.edges, y=true.mutual), colour=\"blue\", size = 5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n\nNow we overshot the observed number of edges and mutuals. Lets decrease those coefficients.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng.sim5 <- simulate(network(57) ~ edges + mutual, coef =c(-1, 2), nsim = 200, sequential = FALSE)\nsummary(g.sim5[[15]] ~ edges + mutual)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n edges mutual \n  1551    551 \n```\n\n\n:::\n\n```{.r .cell-code}\ng.sim.edges = vector()\nfor (i in 1:200)\n  g.sim.edges[i] = summary(g.sim5[[i]] ~ edges)\n\ng.sim.mutual = vector()\nfor (i in 1:200)\n  g.sim.mutual[i] = summary(g.sim5[[i]] ~ mutual)\n\ng.sim.data = as.data.frame(cbind(g.sim.edges, g.sim.mutual))\n\nggplot(g.sim.data, aes(x = g.sim.edges, y = g.sim.mutual)) + geom_point() + \n  geom_point(aes(x=true.edges, y=true.mutual), colour=\"blue\", size = 5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\n\nSo we can see that when we get the coefficients right, in this case those that match the true data generating process, we simulate networks that make our observed network central in that distribution of the simulated networks.\n\nTo summarize Koskinen and Snijders (2013): What we are doing to solve the likelihood equation is we choose a value of theta, simulate graphs x1, x2,..xm, calculate from that sample of graphs of the mean of the statistics of interest (here we are looking at edges and mutual), and then check whether the estimated mean from the simulated graphs is equal to the observed value of those statistics. If the difference is not zero, we then choose another value of theta and repeat the process. This is done until we find value for which the estimated mean of our statistics from the simulated graphs equals our observed values for those statistics. This is the MLE. Note, a brute force approach such as attempted above, is not very efficient. Statnet has built in algorithms that make the search process much more efficient. But the idea is the same.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}